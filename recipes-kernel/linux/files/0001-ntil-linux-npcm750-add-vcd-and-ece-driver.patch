From 8586250940f7505bcb32e959936635328e45f202 Mon Sep 17 00:00:00 2001
From: kwliu <kwliu@nuvoton.com>
Date: Fri, 6 Jul 2018 02:05:44 -0700
Subject: [PATCH] ntil-linux: npcm750: add vcd and ece driver

Change-Id: I55ab6d567ef5431a93036c5eb5809d468ed44802
---
 arch/arm/boot/dts/nuvoton-npcm750-evb.dts |   7 +
 arch/arm/boot/dts/nuvoton-npcm750.dtsi    |  19 +-
 drivers/video/Kconfig                     |   2 +
 drivers/video/Makefile                    |   3 +
 drivers/video/compression/Kconfig         |   8 +
 drivers/video/compression/Makefile        |   1 +
 drivers/video/compression/hextile.c       | 541 ++++++++++++++++++++++
 drivers/video/compression/ioc.h           |  26 ++
 drivers/video/vcd/Kconfig                 |  16 +
 drivers/video/vcd/Makefile                |   1 +
 drivers/video/vcd/npcm750_vcd.c           | 479 ++++++++++++++++++++
 drivers/video/vcd/vcd.c                   | 729 ++++++++++++++++++++++++++++++
 drivers/video/vcd/vcd.h                   | 215 +++++++++
 13 files changed, 2043 insertions(+), 4 deletions(-)
 mode change 100644 => 100755 arch/arm/boot/dts/nuvoton-npcm750-evb.dts
 mode change 100644 => 100755 arch/arm/boot/dts/nuvoton-npcm750.dtsi
 create mode 100644 drivers/video/compression/Kconfig
 create mode 100644 drivers/video/compression/Makefile
 create mode 100755 drivers/video/compression/hextile.c
 create mode 100755 drivers/video/compression/ioc.h
 create mode 100644 drivers/video/vcd/Kconfig
 create mode 100644 drivers/video/vcd/Makefile
 create mode 100755 drivers/video/vcd/npcm750_vcd.c
 create mode 100755 drivers/video/vcd/vcd.c
 create mode 100755 drivers/video/vcd/vcd.h

diff --git a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
old mode 100644
new mode 100755
index f56cc1e..ff6f5d7
--- a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
@@ -214,6 +214,13 @@
 			status = "okay";
 		};
 
+		vcd: vcd@f0810000 {
+			status = "okay";
+		};
+
+		ece: ece@f0820000 {
+			status = "okay";
+		};
 	};
 
 	apb {
diff --git a/arch/arm/boot/dts/nuvoton-npcm750.dtsi b/arch/arm/boot/dts/nuvoton-npcm750.dtsi
old mode 100644
new mode 100755
index 8555822..fdf08f6
--- a/arch/arm/boot/dts/nuvoton-npcm750.dtsi
+++ b/arch/arm/boot/dts/nuvoton-npcm750.dtsi
@@ -444,11 +444,22 @@
 			interrupts = <0 23 4>;
 		};
 
-		vcd: vcd@0 {
+		vcd: vcd@f0810000 {
 			compatible = "nuvoton,npcm750-vcd";
-			reg = <0xf0810000 0x10000
-			       0xf0820000 0x2000>;
-			interrupts = <0 22 4>, <0 24 4>;
+			reg = <0xf0810000 0x10000>;
+			mem-addr = <0x3e200000>;
+			mem-size = <0x600000>;
+			interrupts = <0 22 4>;
+			status = "disabled";
+		};
+
+		ece: ece@f0820000 {
+			compatible = "nuvoton,npcm750-ece";
+			reg = <0xf0820000 0x2000>;
+			mem-addr = <0x3e800000>;
+			mem-size = <0x600000>;
+			interrupts = <0 24 4>;
+			status = "disabled";
 		};
 
 		pcimbx: pcimbx@f0848000 {
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 3c20af9..6717b68 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -45,5 +45,7 @@ if FB || SGI_NEWPORT_CONSOLE
 
 endif
 
+source "drivers/video/vcd/Kconfig"
+source "drivers/video/compression/Kconfig"
 
 endmenu
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 445b2c2..c32cf74 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -7,6 +7,9 @@ obj-$(CONFIG_LOGO)		  += logo/
 obj-y				  += backlight/
 
 obj-y				  += fbdev/
+obj-$(CONFIG_NPCM750_HEXTILE)     += compression/
+obj-$(CONFIG_NPCM750_VCD)         += vcd/
+
 
 obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
 ifeq ($(CONFIG_OF),y)
diff --git a/drivers/video/compression/Kconfig b/drivers/video/compression/Kconfig
new file mode 100644
index 0000000..afc6d59
--- /dev/null
+++ b/drivers/video/compression/Kconfig
@@ -0,0 +1,8 @@
+#
+# ECE configuration
+#
+
+config NPCM750_HEXTILE
+    tristate "Nuvoton ECE support"
+    ---help---
+      Enable Nuvoton Encoding and Compression Engine.
diff --git a/drivers/video/compression/Makefile b/drivers/video/compression/Makefile
new file mode 100644
index 0000000..82586f0
--- /dev/null
+++ b/drivers/video/compression/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_NPCM750_HEXTILE)		+= hextile.o
diff --git a/drivers/video/compression/hextile.c b/drivers/video/compression/hextile.c
new file mode 100755
index 0000000..56637ff
--- /dev/null
+++ b/drivers/video/compression/hextile.c
@@ -0,0 +1,541 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/unistd.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <asm/fb.h>
+#include "ioc.h"
+
+#define DEV_BUFSIZE 1024
+#define ECE_BA 0xf0820000
+
+/* ECE registers*/
+#define DDA_CTRL        0x0000
+#define DDA_STS         0x0004
+#define FBR_BA          0x0008
+#define ED_BA           0x000C
+#define RECT_XY         0x0010
+#define RECT_DIMEN      0x0014
+#define RESOL           0x001C
+#define HEX_CTRL        0x0040
+#define HEX_RECT_OFFSET 0x0048
+
+#define _LINE_PITCH_IN_BYTES(bytes, bit_field) bytes
+#define LINE_PITCH_IN_BYTES(lp_pair) _LINE_PITCH_IN_BYTES(lp_pair)
+#define _LINE_PITCH_IN_FIELD(bytes, bit_field) bit_field
+#define LINE_PITCH_IN_BIT_FIELD(lp_pair) _LINE_PITCH_IN_FIELD(lp_pair)
+
+#define LP_512   512, 0
+#define LP_1024 1024, 1
+#define LP_2048 2048, 2
+#define LP_2560 2560, 3
+#define LP_4096 4096, 4
+
+#define MA_TILE_WIDTH         16
+#define MA_TILE_HEIGHT        16
+
+struct npcm750_ece {
+	struct mutex mlock;
+	spinlock_t lock;
+	struct device *dev;
+	struct device *dev_p;
+	struct cdev *dev_cdevp;
+	struct class *ece_class;
+	dev_t dev_t;
+	u32 smem_len;
+	u32 smem_start;
+	void __iomem *ece_base_addr;
+	char __iomem *ed_buffer;
+	u32 width;
+	u32 height;
+	u32 ECE_LinePitch_L;
+	u32 ECE_EncGap_L;
+	int initialised;
+};
+
+static u32 ECE_SetFrameBufferBaseAddress(struct npcm750_ece *ece, u32 buffer);
+static u32 ECE_IsRectangleCompressed(struct npcm750_ece *ece);
+static u32 Get_ED_Size(struct npcm750_ece *ece);
+static void Clear_Rect_Offset(struct npcm750_ece *ece);
+static void ECE_EncodeRectangle(struct npcm750_ece *ece,
+	u32 RectOffset_X, u32 RectOffset_Y, u32 Rect_Width, u32 Rect_Height);
+static void ECE_ClearDataReadyStatus(struct npcm750_ece *ece);
+static void ECE_SetLinePitch(struct npcm750_ece *ece, u32 pitch);
+static u32 ECE_SetEncodedDataBaseAddress(struct npcm750_ece *ece);
+
+static ssize_t
+drv_read(struct file *filp, char *buf, size_t count, loff_t *ppos)
+{
+#if 0
+	pr_info("device read[count:%zu][ppos:%d]\n", count, *ppos);
+	struct npcm750_ece *ece = filp->private_data;
+
+	if (*ppos >= ece->smem_len)
+		return 0;
+	if (*ppos + count > ece->smem_len)
+		count = ece->smem_len - *ppos;
+	if (copy_to_user(buf, ece->ed_buffer + *ppos, count))
+		return -EFAULT;
+	*ppos += count;
+#endif
+	return count;
+}
+
+static ssize_t
+drv_write(struct file *filp, const char *buf, size_t count, loff_t *ppos)
+{
+#if 0
+	pr_info("device write[count:%zu][ppos:%d]\n", count, *ppos);
+	if (*ppos >= ece->smem_len)
+		return 0;
+	if (*ppos + count > ece->smem_len)
+		count = ece->smem_len - *ppos;
+	if (copy_from_user(ece->ed_buffer + *ppos, buf, count))
+		return -EFAULT;
+	*ppos += count;
+	pr_info("GOT raw [len:%d]\n", count);
+#endif
+	return count;
+}
+
+static int
+drv_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct npcm750_ece *ece = file->private_data;
+	unsigned long start;
+	u32 len;
+
+	if (!ece)
+		return -ENODEV;
+
+	start = ece->smem_start;
+	len = ece->smem_len;
+
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	fb_pgprotect(file, vma, start);
+	return vm_iomap_memory(vma, start, len);
+}
+
+struct npcm750_ece *registered_ece;
+
+static int drv_open(struct inode *inode, struct file *filp)
+{
+	if (!registered_ece)
+		return -ENODEV;
+
+	filp->private_data = registered_ece;
+
+	return 0;
+}
+
+long drv_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
+{
+	int err = 0;
+	u32 EDsize = 0;
+	struct ioctl_cmd data;
+	struct npcm750_ece *ece = filp->private_data;
+
+	mutex_lock(&ece->mlock);
+	memset(&data, 0, sizeof(data));
+
+	err = copy_from_user(&data, (int __user *)args, sizeof(data))
+		? -EFAULT : 0;
+	if (err) {
+		mutex_unlock(&ece->mlock);
+		return err;
+	}
+
+	switch (cmd) {
+	case SETLP:
+		if (!(data.LP % 512) && data.LP <= 4096)
+			ECE_SetLinePitch(ece, data.LP);
+
+		if (data.w != ece->width || data.h != ece->height) {
+			ece->width = data.w;
+			ece->height = data.h;
+			ECE_SetEncodedDataBaseAddress(ece);
+		}
+		break;
+	case SETFB:
+		if (!data.framebuf) {
+			err = -EFAULT;
+			break;
+		}
+		ECE_SetFrameBufferBaseAddress(ece, data.framebuf);
+		break;
+	case GETED:
+		ECE_EncodeRectangle(ece, data.x, data.y, data.w, data.h);
+		EDsize = Get_ED_Size(ece);
+		Clear_Rect_Offset(ece);
+
+		ece->ECE_EncGap_L =
+			(readl(ece->ece_base_addr + HEX_CTRL) & 0x1F00) >> 8;
+
+		if (ece->ECE_EncGap_L == 0)
+			ece->ECE_EncGap_L = 4;
+
+		data.gap_len = ece->ECE_EncGap_L;
+		data.len = EDsize;
+		err = copy_to_user((int __user *)args, &data, sizeof(data))
+			? -EFAULT : 0;
+		break;
+
+	default:
+		pr_err("What cmd??\n");
+		break;
+	}
+
+	mutex_unlock(&ece->mlock);
+
+	return err;
+}
+
+static int drv_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+struct file_operations const drv_fops = {
+	.read = drv_read,
+	.write = drv_write,
+	.unlocked_ioctl = drv_ioctl,
+	.open = drv_open,
+	.release = drv_release,
+	.mmap = drv_mmap,
+};
+
+static u32 Get_ED_Size(struct npcm750_ece *ece)
+{
+	u32 size = 0;
+	int count = 0;
+
+	while (ECE_IsRectangleCompressed(ece) != 0x100)
+		;
+
+	do {
+		size = (u32)(ece->ed_buffer[0]
+				| (ece->ed_buffer[1] << 8)
+				| (ece->ed_buffer[2]<<16)
+				| (ece->ed_buffer[3]<<24));
+		count++;
+	} while (size == 0 && count < 30);
+
+	ECE_ClearDataReadyStatus(ece);
+	return size;
+}
+
+static void Clear_Rect_Offset(struct npcm750_ece *ece)
+{
+	u32 temp = 0;
+
+	writel(temp, ece->ece_base_addr+HEX_RECT_OFFSET);
+}
+
+/* This routine reset the FIFO as a bypass for Z1 chip */
+static void FifoResetBypass(struct npcm750_ece *ece)
+{
+	u32 temp = 0;
+
+	temp = readl(ece->ece_base_addr+DDA_CTRL);
+	temp &= (~0x1);
+	writel(temp, ece->ece_base_addr+DDA_CTRL);
+
+	temp |= 0x1;
+	writel(temp, ece->ece_base_addr+DDA_CTRL);
+}
+
+/* This routine Encode the desired rectangle */
+static void ECE_EncodeRectangle(struct npcm750_ece *ece,
+	u32 RectOffset_X, u32 RectOffset_Y, u32 Rect_Width, u32 Rect_Height)
+{
+	u32 rectOffset =
+		(RectOffset_Y * ece->ECE_LinePitch_L) + (RectOffset_X * 2);
+	u32 temp;
+	u32 w_tile;
+	u32 h_tile;
+	u32 w_size = 16;
+	u32 h_size = 16;
+
+	FifoResetBypass(ece);
+
+	writel(rectOffset, ece->ece_base_addr + RECT_XY);
+
+	w_tile = Rect_Width >> 4;
+	h_tile = Rect_Height >> 4;
+
+	if (Rect_Width % 16) {
+		w_tile += 1;
+		w_size = Rect_Width % 16;
+	}
+
+	if (Rect_Height % 16 || !h_tile) {
+		h_tile += 1;
+		h_size = Rect_Height % 16;
+	}
+
+	temp = ((w_size - 1) << 11) | ((h_size - 1) << 27)
+		| (w_tile - 1) | ((h_tile - 1) << 16);
+
+	writel(temp, ece->ece_base_addr + RECT_DIMEN);
+}
+
+/* This routine sets the Encoded Data base address */
+static u32 ECE_SetEncodedDataBaseAddress(struct npcm750_ece *ece)
+{
+	writel(ece->smem_start, ece->ece_base_addr + ED_BA);
+	return 0;
+}
+
+/* This routine sets the Frame Buffer base address */
+static u32 ECE_SetFrameBufferBaseAddress(struct npcm750_ece *ece, u32 buffer)
+{
+	writel(buffer, ece->ece_base_addr + FBR_BA);
+	return 0;
+}
+
+
+/* Set the line pitch (in bytes) for the frame buffers. */
+/* Can be on of those values: 512, 1024, 2048, 2560 or 4096 bytes */
+static void ECE_SetLinePitch(struct npcm750_ece *ece, u32 pitch)
+{
+	u32 LinePitchField;
+
+	switch (pitch) {
+	case LINE_PITCH_IN_BYTES(LP_512):
+		LinePitchField = LINE_PITCH_IN_BIT_FIELD(LP_512);
+		break;
+	case LINE_PITCH_IN_BYTES(LP_1024):
+		LinePitchField = LINE_PITCH_IN_BIT_FIELD(LP_1024);
+		break;
+	case LINE_PITCH_IN_BYTES(LP_2048):
+		LinePitchField = LINE_PITCH_IN_BIT_FIELD(LP_2048);
+		break;
+	case LINE_PITCH_IN_BYTES(LP_2560):
+		LinePitchField = LINE_PITCH_IN_BIT_FIELD(LP_2560);
+		break;
+	case LINE_PITCH_IN_BYTES(LP_4096):
+		LinePitchField = LINE_PITCH_IN_BIT_FIELD(LP_4096);
+		break;
+	default:
+		return;
+	}
+
+	ece->ECE_LinePitch_L = pitch;
+	writel(LinePitchField, ece->ece_base_addr + RESOL);
+}
+
+
+/* Return TRUE if a rectangle finished to be compressed */
+static u32 ECE_IsRectangleCompressed(struct npcm750_ece *ece)
+{
+	u32 temp = readl(ece->ece_base_addr + DDA_STS);
+
+	return (temp & 0x100);
+}
+
+/* Rectangle Compressed Data Ready */
+static void
+ECE_ClearDataReadyStatus(struct npcm750_ece *ece)
+{
+	u32 temp = 0;
+
+	temp = readl(ece->ece_base_addr + DDA_STS);
+	temp |= 0x100;
+	writel(temp, ece->ece_base_addr + DDA_STS);
+	temp = readl(ece->ece_base_addr + DDA_STS);
+}
+
+/* Stop and reset the ECE state machine */
+static void ECE_Reset(struct npcm750_ece *ece)
+{
+	u32 temp = 0;
+
+	temp = readl(ece->ece_base_addr + DDA_CTRL);
+	temp &= (~0x1);
+	writel(temp, ece->ece_base_addr + DDA_CTRL);
+
+	temp |= 0x1;
+	writel(temp, ece->ece_base_addr + DDA_CTRL);
+
+	/* Reset ECE Encoder */
+	temp = readl(ece->ece_base_addr + HEX_CTRL);
+	temp |= 0x1;
+	writel(temp, ece->ece_base_addr + HEX_CTRL);
+
+	/* Enable encoding */
+	temp = readl(ece->ece_base_addr + HEX_CTRL);
+	temp &= (~0x1);
+	writel(temp, ece->ece_base_addr + HEX_CTRL);
+	temp = readl(ece->ece_base_addr + HEX_CTRL);
+	temp = 0;
+	writel(temp, ece->ece_base_addr + HEX_RECT_OFFSET);
+
+	ece->ECE_EncGap_L =
+		(readl(ece->ece_base_addr + HEX_CTRL) & 0x1F00) >> 8;
+
+	if (ece->ECE_EncGap_L == 0)
+		ece->ECE_EncGap_L = 4;
+
+}
+
+/* Initialise the ECE block and interface library */
+static int ECE_Initialise(struct npcm750_ece *ece)
+{
+	if (!ece->initialised) {
+		ECE_Reset(ece);
+		ECE_ClearDataReadyStatus(ece);
+		ece->initialised = 1;
+	}
+
+	return 0;
+}
+
+static int npcm750_ece_device_create(struct npcm750_ece *ece)
+{
+	int ret;
+	dev_t dev;
+	struct cdev *dev_cdevp = ece->dev_cdevp;
+
+	if (alloc_chrdev_region(&dev, 0, 1, "hextile") < 0)
+		goto err;
+
+	dev_cdevp = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if (!dev_cdevp)
+		goto err;
+
+	cdev_init(dev_cdevp, &drv_fops);
+	dev_cdevp->owner = THIS_MODULE;
+	ece->dev_t = dev;
+	ret = cdev_add(dev_cdevp, MKDEV(MAJOR(dev),  MINOR(dev)), 1);
+	if (ret < 0) {
+		pr_err("add chr dev failed\n");
+		goto err;
+	}
+
+	ece->ece_class = class_create(THIS_MODULE, "hextile");
+	if (IS_ERR(ece->ece_class)) {
+		ret = PTR_ERR(ece->ece_class);
+		pr_err("Unable to create ece class; errno = %d\n", ret);
+		ece->ece_class = NULL;
+		goto err;
+	}
+
+	ece->dev = device_create(ece->ece_class, ece->dev_p,
+		MKDEV(MAJOR(dev),  MINOR(dev)), ece, "hextile");
+	if (IS_ERR(ece->dev)) {
+		/* Not fatal */
+		pr_err("Unable to create device for ece; errno = %ld\n",
+			PTR_ERR(ece->dev));
+		ece->dev = NULL;
+		goto err;
+	}
+	return 0;
+
+err:
+	if (dev_cdevp != NULL)
+		kfree(dev_cdevp);
+	return ret;
+}
+
+
+static int npcm750_ece_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct npcm750_ece *ece = NULL;
+
+	ece = kzalloc(sizeof(struct npcm750_ece), GFP_KERNEL);
+	if (!ece)
+		return -ENOMEM;
+
+	spin_lock_init(&ece->lock);
+	mutex_init(&ece->mlock);
+
+	of_property_read_u32(pdev->dev.of_node,
+		"mem-addr", &ece->smem_start);
+	of_property_read_u32(pdev->dev.of_node,
+		"mem-size", &ece->smem_len);
+
+	if (request_mem_region(ece->smem_start,
+		ece->smem_len, "npcm750-ece") == NULL) {
+		pr_err("failed to request ece memory\n");
+		return -ENOMEM;
+	}
+
+	ece->ed_buffer = ioremap(ece->smem_start, ece->smem_len);
+	if (!ece->ed_buffer)
+		return -ENOMEM;
+
+	ece->ece_base_addr = of_iomap(pdev->dev.of_node, 0);
+	if (ece->ece_base_addr == NULL) {
+		pr_err("failed to ioremap ECE_BA\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	ece->dev_p = &pdev->dev;
+
+	npcm750_ece_device_create(ece);
+
+	ECE_Initialise(ece);
+
+	ece->width = 640;
+	ece->height = 480;
+	ece->ECE_LinePitch_L = 512;
+
+	ECE_SetEncodedDataBaseAddress(ece);
+
+	registered_ece = ece;
+
+	pr_info("NPCM750 ECE Driver probed\n");
+	return 0;
+
+failed:
+	if (ece != NULL)
+		kfree(ece);
+	return ret;
+}
+
+
+static int npcm750_ece_remove(struct platform_device *pdev)
+{
+	struct npcm750_ece *ece = platform_get_drvdata(pdev);
+
+	device_destroy(ece->ece_class, ece->dev_t);
+	kfree(ece);
+	registered_ece = NULL;
+
+	return 0;
+}
+
+
+static const struct of_device_id npcm750_ece_of_match_table[] = {
+	{ .compatible = "nuvoton,npcm750-ece"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, npcm750_ece_of_match_table);
+
+static struct platform_driver npcm750_ece_driver = {
+	.driver		= {
+		.name	= "npcm750_ece",
+		.of_match_table = npcm750_ece_of_match_table,
+	},
+	.probe		= npcm750_ece_probe,
+	.remove		= npcm750_ece_remove,
+};
+
+module_platform_driver(npcm750_ece_driver);
diff --git a/drivers/video/compression/ioc.h b/drivers/video/compression/ioc.h
new file mode 100755
index 0000000..568078b
--- /dev/null
+++ b/drivers/video/compression/ioc.h
@@ -0,0 +1,26 @@
+#ifndef IOC_H
+#define IOC_H
+
+struct ioctl_cmd {
+	unsigned int framebuf;
+	unsigned int gap_len;
+	char *buf;
+	int len;
+	int x;
+	int y;
+	int w;
+	int h;
+	int LP;
+};
+
+#define IOC_MAGIC 'k'
+#define COPYRD _IOW(IOC_MAGIC, 1 , struct ioctl_cmd)
+#define GETED _IOR(IOC_MAGIC, 2 , struct ioctl_cmd)
+#define CPGET _IOWR(IOC_MAGIC,3 , struct ioctl_cmd)
+#define SETFB _IOW(IOC_MAGIC, 4 , struct ioctl_cmd)
+#define GETFB _IOR(IOC_MAGIC, 5 , struct ioctl_cmd)
+#define SETLP _IOW(IOC_MAGIC, 6 , struct ioctl_cmd)
+#define PDGET _IOW(IOC_MAGIC, 7 , struct ioctl_cmd)
+#define IOC_MAXNR 7
+
+#endif
\ No newline at end of file
diff --git a/drivers/video/vcd/Kconfig b/drivers/video/vcd/Kconfig
new file mode 100644
index 0000000..39dd3f8
--- /dev/null
+++ b/drivers/video/vcd/Kconfig
@@ -0,0 +1,16 @@
+config NPCM750_VCD
+        tristate "Nuvoton npcm750 vcd support"
+        help
+          This enables support for npcm750 vcd.
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/video/vcd/Makefile b/drivers/video/vcd/Makefile
new file mode 100644
index 0000000..80bae9e
--- /dev/null
+++ b/drivers/video/vcd/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_NPCM750_VCD) += vcd.o npcm750_vcd.o
diff --git a/drivers/video/vcd/npcm750_vcd.c b/drivers/video/vcd/npcm750_vcd.c
new file mode 100755
index 0000000..d8e15a1
--- /dev/null
+++ b/drivers/video/vcd/npcm750_vcd.c
@@ -0,0 +1,479 @@
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/compat.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/kobject.h>
+#include <linux/dma-mapping.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <asm/fb.h>
+
+#include "vcd.h"
+
+#define GFX_BA	0xf000e000
+#define GCR_BA	0xf0800000
+#define INTCR1	0x3c
+#define INTCR2	0x60
+#define INTCR3	0x9C
+#define MFSEL1	0x0c
+#define DUMP_STATUS 0
+
+#define VCD_IOC_MAGIC     'v'
+#define VCD_IOCGETINFO	_IOR(VCD_IOC_MAGIC,  1, struct vcd_info)
+#define VCD_IOCSENDCMD	_IOW(VCD_IOC_MAGIC,  2, int)
+#define VCD_IOCCHKRES	_IOR(VCD_IOC_MAGIC,  3, int)
+#define VCD_IOCGETDIFF	_IOR(VCD_IOC_MAGIC,  4, struct vcd_diff)
+#define VCD_IOCDIFFCNT	_IOR(VCD_IOC_MAGIC,  5, int)
+#define VCD_IOC_MAXNR     6
+
+#define VCD_OP_TIMEOUT 100
+
+struct kobject *vcd_kobject;
+struct npcm750_vcd *registered_vcd;
+
+static irqreturn_t npcm750_vcd_interrupt(int irq, void *dev_id)
+{
+	struct device *dev = dev_id;
+	struct npcm750_vcd *vcd = (struct npcm750_vcd *)dev->driver_data;
+	u32 status;
+	u8 done = 0;
+	u8 irq_in;
+
+	spin_lock(&vcd->lock);
+
+	status = vcd_get_status(vcd);
+	irq_in = status >> IRQ;
+
+	if (irq_in) {
+		done = (status >> DONE) & 0x01;
+#if 0
+		pr_info(" BSD3 (%d)\n", (status >> BSD3) & 0x01);
+		pr_info(" BSD2 (%d)\n", (status >> BSD2) & 0x01);
+		pr_info(" HSYNC (%d)\n", (status >> HSYNC) & 0x01);
+		pr_info(" VSYNC (%d)\n", (status >> VSYNC) & 0x01);
+		pr_info(" HLC_CHG (%d)\n", (status >> HLC_CHG) & 0x01);
+		pr_info(" HAC_CHG (%d)\n", (status >> HAC_CHG) & 0x01);
+		pr_info(" HHT_CHG (%d)\n", (status >> HHT_CHG) & 0x01);
+		pr_info(" HCT_CHG (%d)\n", (status >> HCT_CHG) & 0x01);
+		pr_info(" VHT_CHG (%d)\n", (status >> VHT_CHG) & 0x01);
+		pr_info(" VCT_CHG (%d)\n", (status >> VCT_CHG) & 0x01);
+		pr_info(" IFOR (%d)\n", (status >> IFOR) & 0x01);
+		pr_info(" IFOT (%d)\n", (status >> IFOT) & 0x01);
+		pr_info(" BSD1 (%d)\n", (status >> BSD1) & 0x01);
+		pr_info(" DONE (%d)\n", (status >> DONE) & 0x01);
+#endif
+		if (done) {
+#if VCD_MEM_MAP_BUF
+			int i;
+			if (vcd->smem_base)
+				for (i = 0 ; i < vcd->info.vdisp ; i++) {
+					memcpy(
+					(vcd->smem_base + i * vcd->info.hdisp * 2),
+					vcd->frame_base + (i * vcd->info.line_pitch),
+					vcd->info.hdisp * 2);
+				}
+#endif
+			vcd->diff_cnt = 0;
+			if (vcd->cmd > 0) {
+				vcd_free_diff_table(vcd);
+				vcd_get_diff_table(vcd);
+			}
+		}
+	}
+
+	vcd_clear_status(vcd, status & (0x3ffe | done));
+	spin_unlock(&vcd->lock);
+	return IRQ_HANDLED;
+}
+
+static int
+vcd_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct npcm750_vcd *vcd = file->private_data;
+	u32 start;
+	u32 len;
+
+	if (!vcd)
+		return -ENODEV;
+#if VCD_MEM_MAP_BUF
+	start = vcd->smem_start;
+	len = vcd->smem_len;
+#else
+	start = vcd->frame_start;
+	len = vcd->frame_len;
+#endif
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	fb_pgprotect(file, vma, start);
+
+	return vm_iomap_memory(vma, start, len);
+}
+
+static int
+vcd_release(struct inode *inode, struct file *file)
+{
+	struct npcm750_vcd *vcd = file->private_data;
+#if VCD_MEM_MAP_BUF
+	if (vcd->smem_base)
+		memset(vcd->smem_base, 0x00, vcd->smem_len);
+#endif
+	return 0;
+}
+
+static int
+vcd_open(struct inode *inode, struct file *file)
+{
+	int res = 0;
+
+	if (!registered_vcd)
+		return -ENODEV;
+
+	file->private_data = registered_vcd;
+
+	return res;
+}
+
+
+static long do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
+			unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	long ret = 0;
+	int vcd_cmd;
+	int changed;
+	struct vcd_info info;
+	struct vcd_diff_list *list;
+	struct vcd_diff diff;
+	struct list_head *head = &(vcd->list.list);
+
+	mutex_lock(&vcd->mlock);
+	switch (cmd) {
+	case VCD_IOCGETINFO:
+		info = vcd->info;
+		ret = copy_to_user(argp, &info, sizeof(info))
+			? -EFAULT : 0;
+		break;
+	case VCD_IOCSENDCMD:
+		ret = copy_from_user(&vcd_cmd, argp, sizeof(vcd_cmd))
+			? -EFAULT : 0;
+		vcd_command(vcd, vcd_cmd);
+		if (vcd_cmd > 0) {
+			unsigned long timeout;
+			/* Wait for cmd to complete */
+			timeout = jiffies + VCD_OP_TIMEOUT;
+			while (!vcd_is_op_ok(vcd)) {
+				if (time_after(jiffies, timeout)) {
+					vcd_reset(vcd);
+					break;
+				}
+				cpu_relax();
+			}
+		}
+		break;
+	case VCD_IOCCHKRES:
+		changed = vcd_check_res(vcd);
+		ret = copy_to_user(argp, &changed, sizeof(changed))
+			? -EFAULT : 0;
+		break;
+	case VCD_IOCGETDIFF:
+		if (vcd->diff_cnt == 0) {
+			diff.x = 0;
+			diff.y = 0;
+			diff.w = vcd->info.hdisp;
+			diff.h = vcd->info.vdisp;
+		} else {
+			list = list_first_entry_or_null(head,
+				struct vcd_diff_list, list);
+			if (!list) {
+				diff.x = 0;
+				diff.y = 0;
+				diff.w = 0;
+				diff.h = 0;
+			} else {
+				diff.x = list->diff.x;
+				diff.y = list->diff.y;
+				diff.w = list->diff.w;
+				diff.h = list->diff.h;
+			}
+			if (list) {
+				list_del(&list->list);
+				kfree(list);
+				vcd->diff_cnt--;
+			}
+		}
+		ret = copy_to_user(argp, &diff, sizeof(struct vcd_diff))
+			? -EFAULT : 0;
+		break;
+	case VCD_IOCDIFFCNT:
+		ret = copy_to_user(argp, &vcd->diff_cnt, sizeof(int))
+			? -EFAULT : 0;
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&vcd->mlock);
+	return ret;
+}
+
+static long vcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct npcm750_vcd *vcd = file->private_data;
+
+	if (!vcd)
+		return -ENODEV;
+	return do_vcd_ioctl(vcd, cmd, arg);
+}
+
+static const struct file_operations vcd_fops = {
+	.owner		= THIS_MODULE,
+	.open		= vcd_open,
+	.release	= vcd_release,
+	.mmap		= vcd_mmap,
+	.unlocked_ioctl = vcd_ioctl,
+};
+
+static ssize_t
+res_show(struct kobject *kobj_p, struct kobj_attribute *attr, char *buf)
+{
+	struct device *dev = container_of(kobj_p->parent, struct device, kobj);
+	struct npcm750_vcd *vcd = (struct npcm750_vcd *)dev->driver_data;
+
+	return sprintf(buf, "%d x %d : %zu\n",
+		vcd->info.hdisp, vcd->info.vdisp, vcd->info.pixelClock);
+}
+
+static ssize_t
+cmd_store(struct kobject *kobj_p, struct kobj_attribute *attr,
+	const char *buf, size_t count)
+
+{
+	struct device *dev = container_of(kobj_p->parent, struct device, kobj);
+	struct npcm750_vcd *vcd = (struct npcm750_vcd *)dev->driver_data;
+	int cmd = 0, ret;
+
+	ret = sscanf(buf, "%du", &cmd);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (cmd < 0 || cmd > 2)
+		return count;
+
+	if (vcd_check_res(vcd))
+		vcd_command(vcd, 0);
+
+	vcd_command(vcd, cmd);
+
+	return count;
+}
+
+static struct kobj_attribute vcd_res_attr =
+	__ATTR(resolution, 0644, res_show, NULL);
+static struct kobj_attribute vcd_cmd_attr =
+	__ATTR(cmd, 0644, NULL, cmd_store);
+
+static struct attribute *vcd_sys_attrs[] = {
+	&vcd_res_attr.attr,
+	&vcd_cmd_attr.attr,
+	NULL,
+};
+
+static struct attribute_group vcd_sys_attr_group = {
+	.attrs = vcd_sys_attrs,
+};
+
+struct class *vcd_class;
+
+static int npcm750_vcd_device_create(struct npcm750_vcd *vcd)
+{
+	int ret;
+	dev_t dev;
+	struct cdev *dev_cdevp = NULL;
+
+	if (alloc_chrdev_region(&dev, 0, 1, "vcd") < 0)
+		goto err;
+
+	vcd->dev_n = dev;
+
+	dev_cdevp = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if (dev_cdevp == NULL)
+		goto err;
+
+	cdev_init(dev_cdevp, &vcd_fops);
+	dev_cdevp->owner = THIS_MODULE;
+	ret = cdev_add(dev_cdevp, MKDEV(MAJOR(dev),  MINOR(dev)), 1);
+	if (ret < 0) {
+		pr_err("add chr dev failed\n");
+		goto err;
+	}
+
+	vcd_class = class_create(THIS_MODULE, "vcd");
+	if (IS_ERR(vcd_class)) {
+		ret = PTR_ERR(vcd_class);
+		pr_err("Unable to create vcd class; errno = %d\n", ret);
+		vcd_class = NULL;
+		goto err;
+	}
+
+	vcd->dev = device_create(vcd_class, vcd->dev_p,
+			MKDEV(MAJOR(dev),  MINOR(dev)), vcd, "vcd");
+	if (IS_ERR(vcd->dev)) {
+		/* Not fatal */
+		pr_err("Unable to create device for vcd; errno = %ld\n",
+			PTR_ERR(vcd->dev));
+		vcd->dev = NULL;
+		goto err;
+	}
+
+	vcd_kobject = kobject_create_and_add("vcd_op", &(vcd->dev->kobj));
+
+	ret = sysfs_create_group(vcd_kobject, &vcd_sys_attr_group);
+	if (ret) {
+		kobject_put(vcd_kobject);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	if (dev_cdevp != NULL)
+		kfree(dev_cdevp);
+	return ret;
+}
+
+static int npcm750_vcd_probe(struct platform_device *pdev)
+{
+	struct npcm750_vcd *vcd = NULL;
+	void __iomem *reg_base;
+	int irq, ret = 0;
+
+	vcd = kzalloc(sizeof(struct npcm750_vcd), GFP_KERNEL);
+	if (!vcd)
+		return -ENOMEM;
+
+	spin_lock_init(&vcd->lock);
+	mutex_init(&vcd->mlock);
+
+	of_property_read_u32(pdev->dev.of_node,
+		"mem-addr", &vcd->frame_start);
+	of_property_read_u32(pdev->dev.of_node,
+		"mem-size", &vcd->frame_len);
+
+	if (request_mem_region(vcd->frame_start,
+		vcd->frame_len, "npcm750_vcd") == NULL) {
+		pr_err("failed to request vcd memory\n");
+		return -ENOMEM;
+	}
+
+	vcd->frame_base = ioremap(vcd->frame_start, vcd->frame_len);
+	if (!vcd->frame_base) {
+		pr_err("failed to alloc vcd memory\n");
+		return -ENOMEM;
+	}
+
+	reg_base = of_iomap(pdev->dev.of_node, 0);
+	if (IS_ERR(reg_base)) {
+		pr_err("failed to ioremap VCD_BA\n");
+		ret = PTR_ERR(reg_base);
+		goto err;
+	}
+
+	vcd->reg = (struct vcd_reg *)reg_base;
+
+	vcd->gcr_ba = ioremap(GCR_BA, 0x200);
+	if (IS_ERR(vcd->gcr_ba)) {
+		pr_err("failed to ioremap GCR_BA\n");
+		ret = PTR_ERR(vcd->gcr_ba);
+		goto err;
+	}
+
+	vcd->intcr = vcd->gcr_ba + INTCR1;
+	vcd->intcr2 = vcd->gcr_ba + INTCR2;
+	vcd->intcr3 = vcd->gcr_ba + INTCR3;
+	vcd->mfsel1 = vcd->gcr_ba + MFSEL1;
+
+	reg_base = ioremap(GFX_BA, 0x100);
+	if (IS_ERR(vcd->gfx)) {
+		pr_err("failed to ioremap GFX_BA\n");
+		ret = PTR_ERR(vcd->gfx);
+		goto err;
+	}
+
+	vcd->gfx = (struct gfx_reg *)reg_base;
+	vcd->dev_p = &pdev->dev;
+
+	ret = npcm750_vcd_device_create(vcd);
+	if (ret) {
+		pr_err("failed to create device\n");
+		goto err;
+	}
+
+	ret = vcd_init(vcd);
+	if (ret) {
+		pr_err("failed to init vcd module\n");
+		goto err;
+	}
+
+	irq = of_irq_get(pdev->dev.of_node, 0);
+	ret = request_irq(irq, npcm750_vcd_interrupt,
+				IRQF_SHARED, "vcd", vcd->dev);
+	if (ret) {
+		pr_err("failed to request irq\n");
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, vcd);
+
+	INIT_LIST_HEAD(&vcd->list.list);
+
+	registered_vcd = vcd;
+
+	pr_info("NPCM750 VCD Driver probed\n");
+	return 0;
+
+err:
+	pr_err("failed to probe NPCM750 VCD Driver\n");
+	kfree(vcd);
+	return ret;
+}
+
+static int npcm750_vcd_remove(struct platform_device *pdev)
+{
+	struct npcm750_vcd *vcd = platform_get_drvdata(pdev);
+
+	device_destroy(vcd_class, vcd->dev_n);
+
+	vcd_unmap_frame_memory(vcd);
+
+	kfree(vcd);
+
+	registered_vcd = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id npcm750_vcd_of_match_table[] = {
+	{ .compatible = "nuvoton,npcm750-vcd"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, npcm750_vcd_of_match_table);
+
+static struct platform_driver npcm750_vcd_driver = {
+	.driver		= {
+		.name	= "npcm750_vcd",
+		.of_match_table = npcm750_vcd_of_match_table,
+	},
+	.probe		= npcm750_vcd_probe,
+	.remove		= npcm750_vcd_remove,
+};
+
+module_platform_driver(npcm750_vcd_driver);
diff --git a/drivers/video/vcd/vcd.c b/drivers/video/vcd/vcd.c
new file mode 100755
index 0000000..8f7da0c
--- /dev/null
+++ b/drivers/video/vcd/vcd.c
@@ -0,0 +1,729 @@
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include "vcd.h"
+
+static void vcd_set_line_pitch(struct npcm750_vcd *vcd, u32 lineBytes)
+{
+	struct vcd_reg *reg = vcd->reg;
+	/* Pitch must be a power of 2, >= lineBytes,*/
+	/* at least 512, and no more than 4096. */
+	u32 pitch = 512;
+
+	while ((pitch < lineBytes) && (pitch < 4096))
+		pitch *= 2;
+
+	write32((pitch << 16) | pitch, reg->fb_lp);
+}
+
+static int vcd_bytes_per_pixel(struct npcm750_vcd *vcd)
+{
+
+	struct vcd_reg *reg = vcd->reg;
+
+	switch ((read32(reg->vcd_mode) & 0x30) >> 4) {
+	case VCD_MODE_COLOR_NORM:
+		return 2;
+	case VCD_MODE_COLOR_222:
+	case VCD_MODE_COLOR_666:
+		return 1;
+	case VCD_MODE_COLOR_888:
+		return 4;
+	}
+	return 0;
+}
+
+static int
+vcd_set_frame_addrs(struct npcm750_vcd *vcd, u32 PhysAddrA, u32 PhysAddrB)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(PhysAddrA, reg->fba_adr);
+	write32(PhysAddrB, reg->fbb_adr);
+
+	/* Check the alignment by reading the addresses */
+	/* back from the VCD registers */
+	if ((read32(reg->fba_adr) != PhysAddrA)
+		|| (read32(reg->fbb_adr) != PhysAddrB))
+		return -EFAULT;
+
+	vcd->info.vcd_fb = PhysAddrA;
+	return 0;
+}
+
+static int vcd_set_color_mode(struct npcm750_vcd *vcd, u32 cm)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 mode = read32(reg->vcd_mode) & ~BIT(1);
+
+	mode |= (cm << 1);
+
+	write32(mode , reg->vcd_mode);
+	return 0;
+}
+
+static int vcd_set_idbc(struct npcm750_vcd *vcd, u8 initDiff)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	u32 mode = read32(reg->vcd_mode) & ~BIT(3);
+
+	if (initDiff)
+		mode |= BIT(3);
+
+	write32(mode, reg->vcd_mode);
+	return 0;
+}
+
+int vcd_set_pixel_format(struct npcm750_vcd *vcd, enum vcd_pixel_format format)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 mode = read32(reg->vcd_mode) & ~(0x30);
+	u32 value;
+
+	switch (format) {
+	case rgb_555:
+		value = VCD_MODE_COLOR_NORM;
+	break;
+	case rgb_222:
+		value = VCD_MODE_COLOR_222;
+	break;
+	case rgb_666:
+		value = VCD_MODE_COLOR_666;
+	break;
+	default:
+		return -EINVAL;
+	}
+
+	write32(mode | (value << 4), reg->vcd_mode);
+	vcd_set_line_pitch(vcd, vcd->info.hdisp * vcd_bytes_per_pixel(vcd));
+	return 0;
+}
+
+static void vcd_set_int(struct npcm750_vcd *vcd, u32 flags)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(flags, reg->vcd_inte);
+}
+
+int vcd_is_int_en(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return (read32(reg->vcd_inte) != 0);
+}
+
+static u32 vcd_get_cur_line(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return ((read32(reg->vcd_stat) >> 16) & 0x7ff);
+}
+
+static u32 vcd_get_line_pitch(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return read32(reg->fb_lp) & 0xffff;
+}
+
+#if 0
+static u32 vcd_convert_to_rgb555(struct npcm750_vcd *vcd, u32 pixel)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 r = 0, g = 0, b = 0;
+
+	switch ((read32(reg->vcd_mode) >> 4) & 0x03) {
+	case VCD_MODE_COLOR_NORM:
+		return pixel;
+	case VCD_MODE_COLOR_222:
+		r = (((pixel >> 4) & 3) * 31) / 3;
+		g = (((pixel >> 2) & 3) * 31) / 3;
+		b = (((pixel >> 0) & 3) * 31) / 3;
+		break;
+	case VCD_MODE_COLOR_666:
+		b = ((pixel % 6) * 31) / 5;
+		pixel = pixel / 6;
+		g = ((pixel % 6) * 31) / 5;
+		pixel = pixel / 6;
+		r = ((pixel % 6) * 31) / 5;
+		break;
+	case VCD_MODE_COLOR_888:
+		r = (pixel >> 19) & 0x1f;
+		g = (pixel >> 11) & 0x1f;
+		r = (pixel >> 3) & 0x1f;
+		break;
+	}
+
+	return (r << 10) | (g << 5) | b;
+}
+
+static int
+vcd_en_blue_de(struct npcm750_vcd *vcd, u32 blueColour,
+	u32 pixelCount, u32 tolerance)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 vcd_bsd = 0;
+	u32 blueField = vcd_convert_to_rgb555(vcd, blueColour) & 0xffff;
+	u32 tolField;
+	u32 countField = (pixelCount / 512) & 0xfff;
+
+	if ((pixelCount / 512) > countField)
+		return -EINVAL;
+
+	switch (tolerance) {
+	case 0:
+		tolField = VCD_BSD_BTOL_0;
+		break;
+	case 1:
+		tolField = VCD_BSD_BTOL_1;
+		break;
+	case 2:
+		tolField = VCD_BSD_BTOL_2;
+		break;
+	case 4:
+		tolField = VCD_BSD_BTOL_4;
+		break;
+	case 6:
+		tolField = VCD_BSD_BTOL_6;
+		break;
+	case 8:
+		tolField = VCD_BSD_BTOL_8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	vcd_bsd = 1 | (tolField << 1) | (countField << 4) | (blueField << 16);
+	write32(vcd_bsd, reg->vcd_bsd1);
+	return 0;
+}
+
+int vcd_dis_blue_de(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(0, reg->vcd_bsd1);
+	return 0;
+}
+#endif
+
+static int vcd_is_hw_present(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(0xffffffff, reg->fb_lp);
+	write32(0xffffffff, reg->cap_res);
+
+	if ((read32(reg->fb_lp) != 0xfe00fe00) ||
+		(read32(reg->cap_res) != 0x7ff07ff)) {
+		pr_err("VCD block not present\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static u8 gfx_is_mga_mode(struct npcm750_vcd *vcd)
+{
+	struct gfx_reg *gfx = vcd->gfx;
+
+	return ((read32(gfx->dispst) & 0x80) == 0x80);
+}
+static u32 gfx_hor_res(struct npcm750_vcd *vcd)
+{
+	struct gfx_reg *gfx = vcd->gfx;
+
+	return (((read32(gfx->hvcnth) & 0x07) << 8)
+		+ ((read32(gfx->hvcntl) & 0xff) + 1));
+}
+
+static u32 gfx_ver_res(struct npcm750_vcd *vcd)
+{
+	struct gfx_reg *gfx = vcd->gfx;
+
+	return (((read32(gfx->vvcnth) & 0x07) << 8)
+		+ (read32(gfx->vvcntl) & 0xff));
+}
+
+static u32 vcd_get_hres(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 apb_HorRes;
+	u32 HorAct;
+
+	apb_HorRes = gfx_hor_res(vcd);
+
+	if (gfx_is_mga_mode(vcd))
+		return (apb_HorRes > VCD_MAX_WIDTH) ? VCD_MAX_WIDTH:apb_HorRes;
+
+	HorAct = read32(reg->hor_ac_tim) & 0x7ff;
+	/* The following 'if' checks if HorAct is wrong */
+	if (((apb_HorRes + 40) < HorAct) || (HorAct > 50))
+		return ((apb_HorRes & 0xFF0) > VCD_MAX_WIDTH)
+			? VCD_MAX_WIDTH:(HorAct & 0xFF0);
+
+	return vcd->info.hdisp;
+}
+
+static u32 vcd_get_vres(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 apb_VerRes;
+	u32 VerAct;
+
+	if (gfx_is_mga_mode(vcd)) {
+		apb_VerRes = gfx_ver_res(vcd);
+		return (apb_VerRes > VCD_MAX_HIGHT) ? VCD_MAX_HIGHT:apb_VerRes;
+	}
+
+	VerAct = read32(reg->hor_lin_tim) & 0x7ff;
+	if (VerAct > 50)
+		return (VerAct > VCD_MAX_HIGHT) ? VCD_MAX_HIGHT:VerAct;
+	return vcd->info.vdisp;
+}
+
+static u32 vcd_get_pclk(struct npcm750_vcd *vcd)
+{
+	struct gfx_reg *gfx = vcd->gfx;
+
+	u8 gpllfbdv109 = (read32(gfx->gpllst) & 0xc0) >> 6;
+	u8 gpllfbdv8 = (read32(gfx->gpllindiv) & 0x80) >> 7;
+	u8 gpllfbdiv = read32(gfx->gpllfbdiv);
+	u8 gpllindiv = read32(gfx->gpllindiv) & 0x3f;
+	u8 gpllst_pllotdiv1 = read32(gfx->gpllst) & 0x07;
+	u8 gpllst_pllotdiv2 = (read32(gfx->gpllst) & 0x38) >> 3;
+
+	u32 PllFbDiv = (512 * gpllfbdv109 + 256 * gpllfbdv8 + gpllfbdiv);
+	u32 PllInOtDiv = (gpllindiv * gpllst_pllotdiv1 * gpllst_pllotdiv2);
+
+	if (PllFbDiv == 0 || PllInOtDiv == 0)
+		return 0;
+
+	return ((PllFbDiv * 25000) / PllInOtDiv) * 1000;
+}
+
+static int vcd_set_capres(struct npcm750_vcd *vcd, u32 horRes, u32 vertRes)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 res = ((vertRes & 0x7ff) | ((horRes & 0x7ff) << 16));
+
+	if ((horRes > VCD_MAX_WIDTH) || (vertRes > VCD_MAX_HIGHT))
+		return -EINVAL;
+
+	write32(res, reg->cap_res);
+
+	/* Read back the register to check that the values were valid */
+	if (read32(reg->cap_res) !=  res)
+		return -EINVAL;
+
+	return 0;
+}
+
+int vcd_reset(struct npcm750_vcd *vcd)
+{
+	struct	vcd_reg *reg = vcd->reg;
+	static u8 second_reset = 1;
+
+	write32(read32(reg->vcd_cmd) | 0x02, reg->vcd_cmd);
+	while (!(read32(reg->vcd_stat) & 0x01))
+		continue;
+
+	if (second_reset)
+		write32(read32(vcd->intcr2) | BIT(GIRST2), vcd->intcr2);
+
+	write32(0xffffffff, reg->vcd_stat);
+
+	write32(read32(vcd->intcr2) & ~BIT(GIRST2), vcd->intcr2);
+	return 0;
+}
+
+static void vcd_set_dehs_mode(struct npcm750_vcd *vcd, u8 signalIsDe)
+{
+	struct	vcd_reg *reg = vcd->reg;
+
+	write32(read32(reg->vcd_mode)
+		| ((signalIsDe ? 0:1) << 11), reg->vcd_mode);
+	write32(read32(vcd->intcr) | ((signalIsDe ? 0:1) << 27), vcd->intcr);
+}
+
+static void vcd_set_kvm_bw(struct npcm750_vcd *vcd, int bandwidth)
+{
+	struct	vcd_reg *reg = vcd->reg;
+
+	u32 mode = read32(reg->vcd_mode) & ~BIT(16);
+
+	if (gfx_is_mga_mode(vcd) == 0)
+		bandwidth = 1;
+
+	write32(mode | (bandwidth << 16), reg->vcd_mode);
+}
+
+static u32 vcd_htotal(struct npcm750_vcd *vcd)
+{
+	return vcd->info.hdisp + vcd->info.hfrontporch
+		+ vcd->info.hsync + vcd->info.hbackporch;
+}
+
+static u32 vcd_vtotal(struct npcm750_vcd *vcd)
+{
+	return vcd->info.vdisp + vcd->info.vfrontporch
+		+ vcd->info.vsync + vcd->info.vbackporch;
+}
+
+static int vcd_vsync_period(struct npcm750_vcd *vcd)
+{
+	if (vcd->info.pixelClock == 0)
+		return 0;
+
+	return (vcd_htotal(vcd) * vcd_vtotal(vcd) * 200)
+		/ (vcd->info.pixelClock / 5);
+}
+
+static void vcd_detect_video_mode(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(0x3f0, reg->vcd_stat);
+	vcd->mga_mode = gfx_is_mga_mode(vcd);
+	vcd->info.hdisp = vcd_get_hres(vcd);
+	vcd->info.vdisp = vcd_get_vres(vcd);
+	vcd->video_name = "Digital";
+	vcd->info.pixelClock = vcd_get_pclk(vcd);
+	vcd->info.hfrontporch = 0;
+	vcd->info.hbackporch = 0;
+	vcd->info.vfrontporch = 0;
+	vcd->info.vbackporch = 0;
+	vcd->info.hpositive = 1;
+	vcd->info.vpositive = 0;
+
+	if (vcd->info.hdisp > VCD_MAX_WIDTH)
+		vcd->info.hdisp = VCD_MAX_WIDTH;
+
+	if (vcd->info.vdisp > VCD_MAX_HIGHT)
+		vcd->info.vdisp = VCD_MAX_HIGHT;
+
+	if (vcd_vsync_period(vcd) > 0)
+		vcd->info.refresh_rate = 1000 / vcd_vsync_period(vcd);
+
+	vcd_set_capres(vcd, vcd->info.hdisp, vcd->info.vdisp);
+	vcd_set_line_pitch(vcd, vcd->info.hdisp * vcd_bytes_per_pixel(vcd));
+	vcd->info.line_pitch = vcd_get_line_pitch(vcd);
+	vcd_set_kvm_bw(vcd, vcd->info.pixelClock > 120000000UL);
+	vcd_reset(vcd);
+
+	pr_info("[VCD] vcd_mode = 0x%x, %s mode\n",
+		(u32)read32(reg->vcd_mode),
+		gfx_is_mga_mode(vcd) ? "Hi Res" : "VGA");
+
+	pr_info("[VCD] digital mode: %d x %d, Pixel Clk %zuKHz\n",
+		vcd->info.hdisp, vcd->info.vdisp,
+		(u32)(vcd->info.pixelClock/1000));
+}
+
+static int vcd_map_frame_memory(struct npcm750_vcd *vcd)
+{
+	dma_addr_t map_dma;
+	unsigned int map_size;
+#if VCD_MEM_MAP_BUF
+	map_size = PAGE_ALIGN((vcd->info.hdisp + 16)
+		* (vcd->info.vdisp + 16) * 2);
+
+	vcd->smem_base = dma_alloc_coherent(vcd->dev_p,
+						map_size, &map_dma,
+						GFP_KERNEL);
+	if (vcd->smem_base) {
+		memset(vcd->smem_base, 0x00, map_size);
+		vcd->smem_start = map_dma;
+		vcd->smem_len = map_size;
+	} else {
+		pr_err("failed to alloc vcd memory\n");
+		return -ENOMEM;
+	}
+#endif
+	return 0;
+}
+
+void vcd_unmap_frame_memory(struct npcm750_vcd *vcd)
+{
+#if VCD_MEM_MAP_BUF
+	if (vcd->smem_base)
+		dma_free_coherent(vcd->dev, PAGE_ALIGN(vcd->smem_len),
+			vcd->smem_base, vcd->smem_start);
+#endif
+}
+
+int vcd_is_busy(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return (read32(reg->vcd_stat) >> BUSY) & 0x01;
+}
+
+int vcd_is_done(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return (read32(reg->vcd_stat) & (BIT(DONE) | BIT(IFOR))) != 0;
+}
+
+int vcd_is_op_ok(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u8 changed = 0;
+	u32 vdisp = read32(reg->cap_res) & 0x7ff;
+	u32 vcd_stat = read32(reg->vcd_stat);
+	u32 mask = BIT(DONE) | BIT(IFOR) | BIT(BUSY);
+
+	if (vcd->info.hdisp == 0 ||
+		vcd->info.vdisp == 0 ||
+		vcd->info.pixelClock == 0)
+		return 1;
+
+	changed = ((vcd->info.hdisp != vcd_get_hres(vcd)) ||
+		(vcd->info.vdisp != vcd_get_vres(vcd)) ||
+		(vcd->mga_mode != gfx_is_mga_mode(vcd)) ||
+		(vcd->info.pixelClock != vcd_get_pclk(vcd)));
+
+	if (changed)
+		return 1;
+
+	return ((vcd_stat & mask) == 0) && (vcd_get_cur_line(vcd) == vdisp);
+}
+
+u32 vcd_get_status(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	return read32(reg->vcd_stat);
+}
+
+void vcd_clear_status(struct npcm750_vcd *vcd, u32 flags)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	write32(flags, reg->vcd_stat);
+}
+
+int vcd_command(struct npcm750_vcd *vcd, u32 value)
+{
+	struct vcd_reg *reg = vcd->reg;
+	u32 cmd;
+	int rc;
+
+	if (vcd_is_busy(vcd))
+		/* Not ready for another command */
+		return -EBUSY;
+
+	/* Clear the status flags that could be set by this command */
+	write32(read32(reg->vcd_stat) | BIT(3) | BIT(2), reg->vcd_stat);
+
+	cmd = read32(reg->vcd_cmd) & ~(0x70);
+	cmd |= (value << 4);
+
+	write32(cmd, reg->vcd_cmd);
+	write32(cmd | BIT(0), reg->vcd_cmd);
+
+	vcd->cmd = value;
+	return rc;
+}
+
+int vcd_check_res(struct npcm750_vcd *vcd)
+{
+	u8 changed;
+
+	/* check with GFX registers if resolution changed from last time */
+	changed = ((vcd->info.hdisp != vcd_get_hres(vcd)) ||
+		(vcd->info.vdisp != vcd_get_vres(vcd)) ||
+		(vcd->mga_mode != gfx_is_mga_mode(vcd)) ||
+		(vcd->info.pixelClock != vcd_get_pclk(vcd)));
+
+
+	if (changed) {
+#if 0
+		/* wait for valid horizontal resolution */
+		while (vcd_get_hres(vcd) < 100 ||
+			vcd_get_vres(vcd) < 100 ||
+			vcd_get_pclk(vcd) == 0)
+			mdelay(10);
+#endif
+		vcd_set_int(vcd, 0);
+#if 0
+		vcd_dis_blue_de(vcd);
+#endif
+		vcd_detect_video_mode(vcd);
+		vcd_unmap_frame_memory(vcd);
+		vcd_map_frame_memory(vcd);
+#if 0
+		vcd_en_blue_de(vcd, 0xffff,
+			vcd->info.hdisp * vcd->info.vdisp * 3 / 4, 1);
+#endif
+		vcd_set_int(vcd, 0x300f);
+	}
+
+	return changed;
+}
+
+void vcd_free_diff_table(struct npcm750_vcd *vcd)
+{
+	struct list_head *head, *pos, *nx;
+	struct vcd_diff_list *tmp;
+
+	head = &(vcd->list.list);
+	list_for_each_safe(pos, nx, head) {
+		tmp = list_entry(pos, struct vcd_diff_list, list);
+		if (tmp) {
+			list_del(&tmp->list);
+			kfree(tmp);
+		}
+	}
+}
+
+int vcd_get_diff_table(struct npcm750_vcd *vcd)
+{
+	struct vcd_reg *reg = vcd->reg;
+
+	int i = 0, j = 0, z = 0, cont_x = 0, cont_y = 0;
+	int tile_perline, tile_perrow, offset_perline, mod;
+	u32 tile_size = 0, tile_cnt = 0;
+	struct vcd_diff_list *list = NULL, *first = NULL;
+	struct list_head *head = &(vcd->list.list);
+
+	tile_perline = vcd->info.hdisp >> 4;
+	mod = vcd->info.hdisp % 16;
+	if (mod != 0)
+		tile_perline += 1;
+
+	tile_perrow = vcd->info.vdisp >> 4;
+	mod = vcd->info.vdisp % 16;
+	if (mod != 0)
+		tile_perrow += 1;
+
+	tile_size = tile_perrow * tile_perline;
+
+	offset_perline = tile_perline >> 5;
+	mod = tile_perline % 32;
+	if (mod != 0)
+		offset_perline += 1;
+
+	offset_perline *= 4;
+	do {
+		for (j = 0 ; j < offset_perline ; j += 4) {
+			if (read32(reg->diff_tbl + (j + i)) != 0) {
+				for (z = 0 ; z < 32; z++) {
+					if ((read32(reg->diff_tbl + (j + i)) >> z) & 0x01) {
+						int offset = z + (j << 3);
+						if (offset < tile_perline) {
+							list = kmalloc(sizeof(struct vcd_diff_list), GFP_KERNEL);
+							list->diff.x = (offset << 4);
+							list->diff.y = (i >> 2);
+							list->diff.w = 16;
+							list->diff.h = 16;
+
+							if (list->diff.x + 16 > vcd->info.hdisp)
+								list->diff.w = vcd->info.hdisp - list->diff.x;
+
+							if (list->diff.y + 16 > vcd->info.vdisp)
+								list->diff.h = vcd->info.vdisp - list->diff.y;
+#if 1
+							if (first == NULL) {
+								first = list;
+								list_add_tail(&(list->list), head);
+								vcd->diff_cnt++;
+							} else {
+								if (((list->diff.x - (first->diff.x + cont_x * 16)) == 16) && (list->diff.y == first->diff.y)) {
+									first->diff.w += list->diff.w;
+									cont_x++;
+									kfree(list);
+								} else if (((list->diff.y - (first->diff.y + cont_y * 16)) == 16) && (list->diff.x == first->diff.x)) {
+									first->diff.h += list->diff.h;
+									cont_y++;
+									kfree(list);
+								} else if (((list->diff.y > first->diff.y) && (list->diff.y < (first->diff.y + first->diff.h))) &&
+									((list->diff.x > first->diff.x) && (list->diff.x < (first->diff.x + first->diff.w)))) {
+									kfree(list);
+								} else {
+									list_add_tail(&(list->list), head);
+									vcd->diff_cnt++;
+									first = list;
+									cont_x = 0;
+									cont_y = 0;
+								}
+							}
+#else
+							list_add_tail(&(list->list), head);
+							vcd->diff_cnt++;
+#endif
+#if 0
+							pr_info("%dx%d rect (%d, %d) -> (%d, %d) cnt(%d)\n",
+								list->diff.w, list->diff.h, list->diff.x, list->diff.y,
+									list->diff.x + list->diff.w, list->diff.y + list->diff.h, vcd->diff_cnt);
+#endif
+						}
+					}
+				}
+			}
+		}
+		i += 64;
+		tile_cnt += tile_perline;
+	} while (tile_cnt < tile_size);
+	return 0;
+}
+
+int vcd_init(struct npcm750_vcd *vcd)
+{
+	struct	vcd_reg *reg = vcd->reg;
+
+	if (vcd_is_hw_present(vcd))
+		return  -ENODEV;
+
+	vcd_reset(vcd);
+
+	/* Initialise capture resolution to a non-zero value */
+	/* so that frame capture will behave sensibly before */
+	/* the true resolution has been determined.*/
+	if (vcd_set_capres(vcd, 640, 480)) {
+		pr_err("failed to set capture resolution\n");
+		return -EINVAL;
+	}
+
+	/* Clear all the 'last' values in the resolution change detection */
+	write32(0, reg->hor_cyc_lst);
+	write32(0, reg->hor_hi_lst);
+	write32(0, reg->hor_ac_lst);
+	write32(0, reg->hor_lin_lst);
+	write32(0, reg->hor_hi_lst);
+	write32(0, reg->ver_cyc_lst);
+	write32(0, reg->ver_hi_lst);
+
+
+	/* Set the FIFO thresholds */
+	write32(0x100350ff, reg->vcd_fifo);
+
+	/* Data enabled is selected */
+	vcd_set_dehs_mode(vcd, 1);
+
+	/* Set frame rate devision */
+	vcd_set_kvm_bw(vcd, 1);
+
+	/* Enable display of KVM GFX and access to memory */
+	write32((read32(vcd->intcr) & ~BIT(8)) & ~BIT(9), vcd->intcr);
+
+	/* Set vrstenw and hrstenw */
+	write32(read32(vcd->intcr2) | BIT(5) | BIT(6), vcd->intcr2);
+
+	/* Select KVM GFX input */
+	write32(read32(vcd->mfsel1) & ~BIT(27), vcd->mfsel1);
+
+	/* Enable the VCD + Vsync edge Rise */
+	write32(read32(reg->vcd_mode) | BIT(0), reg->vcd_mode);
+	write32(read32(reg->vcd_mode) & ~BIT(10), reg->vcd_mode);
+
+	vcd_set_frame_addrs(vcd, vcd->frame_start, vcd->frame_start);
+	vcd_check_res(vcd);
+	vcd_set_idbc(vcd, 1);
+	vcd_set_color_mode(vcd, VCD_MODE_CM_565);
+	vcd_set_int(vcd, 0x300f);
+	return 0;
+}
diff --git a/drivers/video/vcd/vcd.h b/drivers/video/vcd/vcd.h
new file mode 100755
index 0000000..7746d79
--- /dev/null
+++ b/drivers/video/vcd/vcd.h
@@ -0,0 +1,215 @@
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#define GIRST2	2
+
+/* VCD  Status*/
+#define	IRQ			31
+#define	BUSY		30
+#define	CURR_LINE	16
+#define	BSD3		13
+#define	BSD2		12
+#define	HSYNC		11
+#define	VSYNC		10
+#define	HLC_CHG		9
+#define	HAC_CHG		8
+#define	HHT_CHG		7
+#define	HCT_CHG		6
+#define	VHT_CHG		5
+#define	VCT_CHG		4
+#define	IFOR		3
+#define	IFOT		2
+#define	BSD1		1
+#define	DONE		0
+
+#define VCD_MODE_DE_VAL         0x0      // Data Enable mode
+#define VCD_MODE_HS_VAL         0x1      // Horizontal Sync mode
+
+#define VCD_MODE_CM_555         0x0      // Color MODE 555
+#define VCD_MODE_CM_565         0x1      // Color MODE 565
+
+#define VCD_MODE_COLOR_NORM     0x0      // Store 15 bit pixels
+#define VCD_MODE_COLOR_222      0x1      // Convert to 2,2,2 pixels
+#define VCD_MODE_COLOR_666      0x2      // Convert to 6,6,6 colour cube
+#define VCD_MODE_COLOR_888      0x3      // Store 24 bit pixels (reserved)
+
+#define VCD_MODE_VS_EDGE_RISE   0x00000000      // Use VSYNC rising edge
+#define VCD_MODE_VS_EDGE_FALL   0x00000400      // Use VSYNC falling edge
+#define VCD_MODE_HS_EDGE_RISE   0x00000000      // Use HSYNC rising edge
+#define VCD_MODE_HS_EDGE_FALL   0x00000200      // Use HSYNC falling edge
+
+#define VCD_MODE_CMP_WERR_0     0x0      // Pixel compare with no error allowed
+#define VCD_MODE_CMP_WERR_1     0x1      // Pixel compare with +/-1 allowed
+#define VCD_MODE_CMP_WERR_2     0x2      // Pixel compare with +/-2 allowed
+#define VCD_MODE_CMP_WERR_4     0x3      // Pixel compare with +/-4 allowed
+
+#define VCD_CMD_OPER_CAPTURE    0x0      // Capture a single frame
+#define VCD_CMD_OPER_COMPARE2   0x1      // Compare 2 frames
+#define VCD_CMD_OPER_COMPARE    0x2      // Capture and compare new frame
+
+#define VCD_BSD_BTOL_0          0x0      // Blue colour tolerance +/-0
+#define VCD_BSD_BTOL_1          0x1      // Blue colour tolerance +/-1
+#define VCD_BSD_BTOL_2          0x2      // Blue colour tolerance +/-2
+#define VCD_BSD_BTOL_4          0x3      // Blue colour tolerance +/-4
+#define VCD_BSD_BTOL_6          0x4      // Blue colour tolerance +/-6
+#define VCD_BSD_BTOL_8          0x5      // Blue colour tolerance +/-8
+
+#define VCD_RCHG_IG_CHG_0       0x0      // Resolution change tolerance +/-0
+#define VCD_RCHG_IG_CHG_1       0x1      // Resolution change tolerance +/-1
+#define VCD_RCHG_IG_CHG_2       0x2      // Resolution change tolerance +/-2
+#define VCD_RCHG_IG_CHG_4       0x3      // Resolution change tolerance +/-4
+#define VCD_RCHG_IG_CHG_8       0x4      // Resolution change tolerance +/-8
+#define VCD_RCHG_IG_CHG_16      0x5      // Resolution change tolerance +/-16
+#define VCD_RCHG_IG_CHG_32      0x6      // Resolution change tolerance +/-32
+
+#define write32(x, y) writel(x, (void __iomem *)y)
+#define read32(x) readl((void __iomem *)x)
+#define VCD_MAX_WIDTH                   2047
+#define VCD_MAX_HIGHT                   1536
+
+#define VCD_MEM_MAP_BUF 1
+
+enum vcd_pixel_format {rgb_555, rgb_222, rgb_666};
+
+struct gfx_reg {
+	u32 dispst[1];
+	u32 fbadl[1];
+	u32 fbadm[1];
+	u32 fbadh[1];
+	u32 hvcntl[1];
+	u32 hvcnth[1];
+	u32 hbpcntl[1];
+	u32 hbpcnth[1];
+	u32 vvcntl[1];
+	u32 vvcnth[1];
+	u32 vbpcntl[1];
+	u32 vbpcnth[1];
+	u32 curposxl[1];
+	u32 curposxh[1];
+	u32 curposyl[1];
+	u32 curposyh[1];
+	u32 gpllindiv[1];
+	u32 gpllfbdiv[1];
+	u32 gpllst[1];
+	u32 kvmhdst[1];
+	u32 coldep[1];
+	u32 vdispend[1];
+	u32 vblankstr[1];
+	u32 vblankend[1];
+	u32 vtotal[1];
+	u32 vhigh[1];
+	u32 hdispend[1];
+	u32 hblankstr[1];
+	u32 hblankend[1];
+	u32 htotal[1];
+	u32 curwidth[1];
+	u32 curheight[1];
+	u32 curhsxl[1];
+	u32 curhsyl[1];
+	u32 curhsh[1];
+};
+
+struct vcd_reg {
+	u32 diff_tbl[0x2000];
+	u32 fba_adr[1];
+	u32 fbb_adr[1];
+	u32 fb_lp[1];
+	u32 cap_res[1];
+	u32 dvo_del[1];
+	u32 vcd_mode[1];
+	u32 vcd_cmd[1];
+	u32 vcd_stat[1];
+	u32 vcd_inte[1];
+	u32 vcd_bsd1[1];
+	u32 vcd_rchg[1];
+	u32 hor_cyc_tim[1];
+	u32 hor_cyc_lst[1];
+	u32 hor_hi_tim[1];
+	u32 hor_hi_lst[1];
+	u32 ver_cyc_tim[1];
+	u32 ver_cyc_lst[1];
+	u32 ver_hi_tim[1];
+	u32 ver_hi_lst[1];
+	u32 hor_ac_tim[1];
+	u32 hor_ac_lst[1];
+	u32 hor_lin_tim[1];
+	u32 hor_lin_lst[1];
+	u32 vcd_fifo[1];
+	u32 resvered[5];
+	u32 vcd_bsd2[1];
+	u32 vcd_bsd3[1];
+};
+
+struct vcd_info {
+	u32 vcd_fb;
+	u32 pixelClock;
+	u32 line_pitch;
+	int hdisp;
+	int hfrontporch;
+	int hsync;
+	int hbackporch;
+	int vdisp;
+	int vfrontporch;
+	int vsync;
+	int vbackporch;
+	int refresh_rate;
+	int hpositive;
+	int vpositive;
+};
+
+struct vcd_diff {
+	u32 x;
+	u32 y;
+	u32 w;
+	u32 h;
+};
+
+struct vcd_diff_list {
+	struct vcd_diff diff;
+	struct list_head list;
+};
+
+struct npcm750_vcd {
+	struct mutex mlock;
+	spinlock_t lock;
+	struct device *dev;
+	struct device *dev_p;
+	struct vcd_reg *reg;
+	struct gfx_reg *gfx;
+	struct vcd_diff diff;
+	struct vcd_diff_list list;
+	struct vcd_info info;
+	void __iomem *gcr_ba;
+	void __iomem *mfsel1;
+	void __iomem *intcr;
+	void __iomem *intcr2;
+	void __iomem *intcr3;
+	u32 smem_len;
+	u32 smem_start;
+	char __iomem *smem_base;	/* Virtual address */
+	u32 frame_len;
+	u32 frame_start;
+	char __iomem *frame_base;	/* Virtual address */
+	u8 mga_mode;
+	u32 diff_cnt;
+	char *name;
+	char *video_name;
+	int internal_video;   /*1- if from internal GFX, 0- otherwize*/
+	int cmd;
+	dev_t dev_n;
+};
+
+int vcd_is_busy(struct npcm750_vcd *vcd);
+int vcd_is_done(struct npcm750_vcd *vcd);
+int vcd_is_op_ok(struct npcm750_vcd *vcd);
+u32 vcd_get_status(struct npcm750_vcd *vcd);
+void vcd_clear_status(struct npcm750_vcd *vcd, u32 flags);
+int vcd_command(struct npcm750_vcd *vcd, u32 value);
+int vcd_check_res(struct npcm750_vcd *vcd);
+int vcd_init(struct npcm750_vcd *vcd);
+void vcd_unmap_frame_memory(struct npcm750_vcd *vcd);
+int vcd_set_pixel_format(struct npcm750_vcd *vcd, enum vcd_pixel_format format);
+int vcd_is_int_en(struct npcm750_vcd *vcd);
+int vcd_get_diff_table(struct npcm750_vcd *vcd);
+void vcd_free_diff_table(struct npcm750_vcd *vcd);
+int vcd_reset(struct npcm750_vcd *vcd);
-- 
2.7.4

